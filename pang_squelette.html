<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Pang</title>
    <script>

    // ------------------------------
    //  Variables
    // ------------------------------

    // Context
    var context = null;

    // Game state
    var numLevel = 1;

    // Is the game running or not ?
    var isOnFocus = true;
    var pause = false;
    var victory = false;

    // An array of all the balloons in the game
    // With the position, the radius, the velocity and the gravity for this balloon. Plus his color because it is beautiful.
    var balloons = [
        {center: {x: 500, y:30},
        radius:50,
        velocity:{ x: 1, y: 0},
        gravity: {x :0, y: 9.81/1000},
        },

        {center: {x: 300, y:30},
        radius:50,
        velocity:{ x: -1, y: 0},
        gravity: {x :0, y: 9.81/1000},
        }
    ];

    //Balloons related variables
    const BALLOON_SPEED = 0.2;

    // when did we update the game last time ?
    var lastUpdate = Date.now();

    // A beautiful player
    // With his position, his speed, his size and his others variables
    var player = {position: {x: 0, y: 0}, speed: {x: 0, y: 0}, height: 0, width: 0, powerOn: 0, shieldOn: 0, score: 0, livesNumber: 3, color: "blue"};
    const PLAYER_SPEED = 500;
    var isGravity = 0;

    // All the weapons and types of weapons (0= the weapon is not active)
    const GRAPPLE_HOOK_NUMBER = 1 ;
    const TRIDENT_NUMBER = 2 ;

    var weapons = [
        {
            type:0,
            position: {x: 0, y: 0},
            length: 0,
            shooting: false,
        }

    ]

    // Weapons related variables
    const WEAPON_WIDTH = 5;

    // gravity (thanks Newton)
    const GRAVITY = {x: 0, y: 700};

    // All the platforms
    var platformsList = {
        "level1": [
            {
                "position":{
                    "x": 575,
                    "y": 300
                },
                "width": 80,
                "height": 40,
                "exist": true,
                "isDestructible": false
            },
            {
                "position":{
                    "x": 460,
                    "y": 200
                },
                "width": 80,
                "height": 40,
                "exist": true,
                "isDestructible": false
            },
            {
                "position":{
                    "x": 275,
                    "y": 200
                },
                "width": 80,
                "height": 40,
                "exist": true,
                "isDestructible": false
            },
            {
                "position":{
                    "x": 125,
                    "y": 400
                },
                "width": 80,
                "height": 40,
                "exist": true,
                "isDestructible": true
            }
        ]
    }
    var platforms = platformsList.level1;

    // ladders in the game
    const LADDER_WIDTH = 90;
    var laddersList = {
        "level1": [
            {
                "position":{
                    "x": 35,
                    "y": 400
                },
                "width": LADDER_WIDTH,
                "height": 200,
            }
        ]
    };
    var ladders = laddersList.level1;

    // ### GRAPHICS VARIABLES ###
    // Colors
    const DESTRUCTIBLE_PLATFORM_COLOR = "darkgrey";
    const PLATFORM_COLOR = "black";
    const LADDER_COLOR = "gray";
    const BALLOON_COLOR = "red";
    const GRAPPLE_HOOK_COLOR = "red";
    const TRIDENT_COLOR = "orange"

    // ------------------------------
    //  Functions
    // ------------------------------

    /**
     * Moving the player (horizontally)
     */
    playerMove = function(move) {
        switch (move) {
            case 39:
                player.speed.x = PLAYER_SPEED;
                break;
            case 37:
                player.speed.x = -PLAYER_SPEED;
                break;
        }
    }

    /**
     * Stop the player's movement (horizontally)
     */
    playerStopMove = function(move) {
        switch (move) {
            case 39:
                if(player.speed.x > 0) {
                    player.speed.x = 0;
                }
                break;
            case 37:
                if(player.speed.x < 0) {
                    player.speed.x = 0;
                }
                break;
        }
    }

    /**
     * Moving the player (with ladders)
     */
    playerMoveLadder = function(move) {
        if(findLadder() != -1) {
            switch(move) {
                case 38:
                    player.speed.y = -PLAYER_SPEED;
                    break;
                case 40:
                    player.speed.y = PLAYER_SPEED;
                    break;
            }
        }
    }

    /**
     * Stop the player's movement (with ladders)
     */
    playerStopMoveLadder = function() {
        player.speed.y = 0;
    }

    /**
     * Return the ladder array's index
     */
    findLadder = function() {
        var i=0;
        var find = false;

        while(i<ladders.length && !find) {
            if(player.position.x >= ladders[i].position.x - 0.33*player.width && player.position.x <= ladders[i].position.x + ladders[i].width - 0.66*player.width) {
                if(player.position.y >= ladders[i].position.y - 1.1*player.height && player.position.y <= context.height) {
                    find = true;
                } else {
                    i++;
                }
            } else {
                i++
            }
        }

        if(i == ladders.length) {
            i = -1;
        }
        return i;
    }

    /**
     * Detect if the player is on a platform
     */
    detectPlatform = function() {
        var isOn = true;

        for(var i=0; i<platforms.length; i++) {
            if(player.position.x + player.width < platforms[i].position.x || player.position.x > platforms[i].position.x + platforms[i].width || player.position.y > platforms[i].position.y + platforms[i].height || player.position.y + player.height < platforms[i].position.y) {
                isOn = false;
            } else {
                isOn = true;
            }
        }

        return isOn;
    }

    /**
     * Return true if the player is not on the ground, a platform, or a ladder
     */
    isNotOnPlatformOrGround = function() {
        isNot = false;

        if(player.position.y + player.height < context.height && findLadder() == -1 && !detectPlatform()) { // not on the ground
            isNot = true;
        }

        return isNot;
    }

    /**
     * It does exactly what you expect
     */
    function keepPlayerWithinBorder() {
        if(player.position.x < 0) {
            player.position.x = 0;
        } else {
            if(player.position.x > context.width-player.width) {
                player.position.x = context.width-player.width
            }
        }

        if(player.position.y < 0) {
            player.position.y = 0;
        } else {
            if(player.position.y > context.height-player.height) {
                player.position.y = context.height-player.height
            }
        }
    }

    /**
     * It does exactly what you expect
     */
    function keepBalloonWithinBorders(ball){
        //Top
        if(ball.center.y < ball.radius){
            ball.center.y = ball.radius;
            ball.velocity.y = -ball.velocity.y;
        } else {
            //Bottom
            if(ball.center.y > cvs.height - ball.radius){
                ball.center.y = cvs.height - ball.radius;
                ball.velocity.y = -ball.velocity.y;
            }
        }
        //Left
        if(ball.center.x < ball.radius){
            ball.center.x = ball.radius;
            ball.velocity.x = -ball.velocity.x;
        } else {
            //Right
            if(ball.center.x > cvs.width-ball.radius){
                ball.center.x = cvs.width - ball.radius;
                ball.velocity.x = -ball.velocity.x;
            }
        }
        return(ball);
    }

    /**
     * It does exactly what you expect
     */
    function keepBallonOutsideBorders(ballon){
        //Top
        if(ballon.center.y < ballon.radius){
            ballon.center.y = ballon.radius;
            ballon.velocity.y = -ballon.velocity.y;
        } else {
            //Bottom
            if(ballon.center.y > cvs.height - ballon.radius){
                ballon.center.y = cvs.height - ballon.radius;
                ballon.velocity.y = -ballon.velocity.y;
            }
        }
        //Left
        if(ballon.center.x < ballon.radius){
            ballon.center.x = ballon.radius;
            ballon.velocity.x = -ballon.velocity.x;
        } else {
            //Right
            if(ballon.center.x > cvs.width-ballon.radius){
                ballon.center.x = cvs.width - ballon.radius;
                ballon.velocity.x = -ballon.velocity.x;
            }
        }
        return(ballon);
    }

    /**
     * Like FillRect, but for circles
     */
    function fillCircle(circle){
        var canvas = document.getElementById("cvs");
        var context = canvas.getContext("2d");
        context.beginPath();
        context.fillStyle=BALLOON_COLOR;
        context.arc(circle.center.x, circle.center.y, circle.radius, 0, 2 * Math.PI);
        context.fill();
    }

    /**
     * Detect the victory (= no balloon remaining)
     */
    function isVictory(){
        var isOneBalloonRemaining = false;
        var i=0
        while(i<balloons.length && !isOneBalloonRemaining){
            if(balloons[i].radius > 0){
                isOneBalloonRemaining = true;
            }
            i++;
        }
        return(!isOneBalloonRemaining);
    }

    /**
     * Is the balloonX between the x and x + width of the rectangle ? Return boolean
     * Inputs : balloon with x, rectangle with x and width
     */
    function isBetweenX(balloonPosition,rectangle){
        return(balloonPosition.x > rectangle.x && balloonPosition.x < rectangle.x + rectangle.width)
    }

    /**
    *
    *
    */
    function isWeaponBetweenX(weapon,rectangle){
        return(weapon.position.x > rectangle.position.x && weapon.position.x + WEAPON_WIDTH < rectangle.position.x + rectangle.width);
    }

    /**
    *
    *
    */
    function shootWeapon(player){
        switch(player.powerOn){
            case GRAPPLE_HOOK_NUMBER:
                shootGrappleHook(weapons[0]);
            break;

            case TRIDENT_NUMBER:
                shootGrappleHook(weapons[0]);
            break;
        }
    }

    /**
     * Shoot a grapple hook
     */
    function shootGrappleHook(grappleHook){
        if(grappleHook.shooting==false){
            grappleHook.type = player.powerOn;
            grappleHook.shooting = true;
            grappleHook.position = {x: player.position.x+player.width/2 , y: player.position.y+player.height};
            grappleHook.length = 0;
        }
    }

    /**
     * Delete grapple hook
     */
    function deleteWeapon(weapon){
        weapon.type = 0;
        weapon.shooting = false;
        weapon.position = {x:0, y:0};
        weapon.length = 0;
    }

    /**
     * Checking if the grapple hook should stop
     */
    function stopHooks(hook){

        // Hit the top of the screen
        if(hook.position.y - hook.length < 0){
            switch(hook.type){
                case GRAPPLE_HOOK_NUMBER :
                    deleteWeapon(hook);
                break;

                case TRIDENT_NUMBER :
                    hook.shooting = false;
                break;
            }
        } else {

            //Hit a platform
            var isItHittingPlatform = false;

            for(var i=0 ; i<platforms.length ; i++){
                if(platforms[i].exist && isWeaponBetweenX(hook,platforms[i])){
                    if(cvs.height - hook.length < platforms[i].position.y + platforms[i].height){
                        isItHittingPlatform = true;

                        switch(hook.type){
                            case GRAPPLE_HOOK_NUMBER :
                                deleteWeapon(hook);
                                if(platforms[i].isDestructible){
                                    platforms[i].exist = false;
                                }
                            break;

                            case TRIDENT_NUMBER :
                                hook.shooting = false;
                            break;
                        }
                    }
                }
            }

            //Hitting a balloon
            for(var i=0 ; i<balloons.length ; i++){

                if(balloons[i].radius>0 && platforms[i].exist){

                    if(Math.pow(balloons[i].center.x-hook.position.x,2) < Math.pow(balloons[i].radius,2)
                    && balloons[i].center.y+balloons[i].radius > cvs.height-hook.length){

                        deleteWeapon(hook);

                        player.score += balloons[i].radius*10 ;
                        balloons[i].radius = 0;
                    }
                }
            }
        }
    }

    /**
     * Is the balloonX between the x and (x + width) of the rectangle ? Return boolean
     *Inputs : balloon with x, rectangle with x and width
     */
    function isBetweenX(balloonCenter,rectangle){
        return(balloonCenter.x > rectangle.x && balloonCenter.x < rectangle.x + rectangle.width)
    }

    /**
     * Is the balloonY between the y and (y + width) of the rectangle ? Return boolean
     * Inputs : balloon with y, rectangle with y and height
     */
    function isBetweenY(balloonCenter,rectangle){
        return(balloonCenter.y > rectangle.y && balloonCenter.y < rectangle.y + rectangle.height)
    }

    /**
     * Detect a collision between 2 ballons
     */
    function AreBalloonsCollisionning(ball1, ball2){
        if(ball1.radius <= 0 || ball2.radius <= 0){
            return(false);
        }
        return(!(Math.pow(ball1.radius + ball2.radius, 2) <= Math.pow(ball1.center.x - ball2.center.x, 2) + Math.pow(ball1.center.y - ball2.center.y, 2)));
    }

    /**
     * Return 'true' if the balloon touches an angle of a rectangular object
     */
    function collisionsAngles(ball, object){
        return!(object.position.x + object.width <= ball.center.x - ball.radius ||
            object.position.x >= ball.center.x + ball.radius ||
            object.position.y + object.height <= ball.center.y - ball.radius ||
            object.position.y >= ball.center.y + ball.radius);
    }

    /**
     * Return 'true' if the balloon touches the bottom or the upside of a rectangular object
     */
    function collisionsY(ball, object){
        var collision = false;
        if(isBetweenX(ball.center, player.position)){
            if(object.position.y >= ball.center.y + ball.radius ||
            object.position.y + object.height <= ball.center.y - ball.radius){
                collision = true
            }
        }
        return(collision);
    }

    /**
     * Return 'true' if the balloon touches the faces of a rectangular object
     */
    function collisionsX(ball, object){
        var collision = false;
        if(isBetweenY(ball.center, player.position)){
            if(object.position.x >= ball.center.x + ball.radius ||
            object.position.x + object.width <= ball.center.x - ball.radius){
                collision = true;
            }
        }
        return(collision);
    }

    /**
     * Call the other testing functions and return if there's a collision
     */
    function collisionsWithPlayer(ball, object){
        var collisionAngles = collisionsAngles(ball, object);
        var collisionY = collisionsY(ball, object);
        var collisionX = collisionsX(ball, object);
        return(collisionAngles || collisionX || collisionY);
    }

    /**
     * Make sure the balloons are colliding with rectangle objects like platforms
     */
    function keepBallonOutsideObjects(ball, object){
        if(collisionsAngles(ball, object)){
            ball.velocity.x = -ball.velocity.x - 0,7;
            ball.velocity.y = -ball.velocity.y;
        }
        if(collisionsX(ball, object)){
            ball.velocity.x = -ball.velocity.x;
        }
        if(collisionsY(ball, object)){
            ball.velocity.y = -ball.velocity.y;
        }
        return(ball);
    }

    // ------------------------------
    //  Game
    // ------------------------------

    /**
    * Initialization of the game
    */
    init = function() {
       // Initizalisation of the global var context
        context = document.getElementById("cvs").getContext("2d");
        context.width = document.getElementById("cvs").width;
        context.height = document.getElementById("cvs").height;

        //Pause if it is not on focus
        document.body.onblur = function() {
            isOnFocus = false;
        }
        document.body.onfocus = function() {
            isOnFocus = true;
        }

        // 2 listeners on the keyboard (keyup and keydown)
        document.addEventListener("keydown", captureKeyboardPress)
        document.addEventListener("keyup", captureKeyboardReleased)

        // initialization of the player
        player.height = 75;
        player.width = 70;
        player.position.x = context.width/2 - player.width/2;
        player.position.y = context.height - player.height;

        // Go my little game loop, and never stop
        gameLoop();
    }

    /**
    * Game loop
    */
    gameLoop = function() {
        var delta = Date.now()-lastUpdate;
        lastUpdate = Date.now();

        // Run the game if it is not on pause
        if(!isOnFocus || pause){
            document.title = "Pang - en pause";
        } else if(victory){
            document.title = "Pang - gagné !";
            // draw the game
            render();

        } else {
            document.title = "Pang";

            // update of the game's state
            update(delta);
            // draw the game
            render();
        }

        requestAnimationFrame(gameLoop);
    }

    /**
    *  Game update
    *  @param delta the time between now and the last update
    */
    update = function(delta) {
        for(var i=0 ; i<balloons.length ; i++){
            if(balloons[i].radius>0){
                // Update balloons[i].velocity
                balloons[i].velocity.x += balloons[i].gravity.x*delta;
                balloons[i].velocity.y += balloons[i].gravity.y*delta;

                // Update balloons[i].center
                balloons[i].center.x += balloons[i].velocity.x * delta * BALLOON_SPEED;
                balloons[i].center.y += balloons[i].velocity.y * delta * BALLOON_SPEED;

                //No, you will not stick out
                keepBalloonWithinBorders(balloons[i]);

                //Collisions with player
                if(collisionsWithPlayer(balloons[i], player)){
                    pause = true;
                }

                //Don't go into platforms !
                for(var j=0 ; j<platforms.length ; j++){
                    balloons[i] = keepBallonOutsideObjects(balloons[i], platforms[j]);
                }
            }
        }

        //Ballons one and two are collisionning
        if(AreBalloonsCollisionning(balloons[0],balloons[1])){
            balloons[0].velocity.x = -balloons[0].velocity.x;
            balloons[1].velocity.x = -balloons[1].velocity.x;
        }

        // Weapons will deal a lot of damages
        for(var i=0 ; i<weapons.length ; i++){

            if(weapons[i].shooting==true){

                switch(weapons[i].type){

                    case GRAPPLE_HOOK_NUMBER:
                    case TRIDENT_NUMBER:
                        weapons[i].length += 0.3 * delta ;
                    break;
                }
            }
            stopHooks(weapons[i]);
        }

        // New player's position
        var newPosXPlayer = player.position.x + player.speed.x*delta/1000, newPosYPlayer = player.position.y + player.speed.y*delta/1000;
        var newSpdXPlayer = player.speed.x + isGravity*GRAVITY.x*delta/1000, newSpdYPlayer = player.speed.y + isGravity*GRAVITY.y*delta/1000;
        if(findLadder() != -1) {
            if(newPosYPlayer + player.height < ladders[findLadder()].position.y) {
                newPosYPlayer = ladders[findLadder()].position.y - player.height;
            }
        }
        if(isNotOnPlatformOrGround()) {
            isGravity = 1;
        } else {
            isGravity = 0;
        }

        // Update player
        player.position.x = newPosXPlayer;
        player.position.y = newPosYPlayer;
        player.speed.x = newSpdXPlayer;
        player.speed.y = newSpdYPlayer;
        keepPlayerWithinBorder();

        //Detect the victory
        if(isVictory()){
            victory = true;
        }
    }

    /**
    *  Game render
    */
    render = function() {
        // Wiping the screen
        context.clearRect(0, 0, context.width, context.height);
        //context.drawImage(bg_paris, 0, 0, 800, 600);

		// platforms drawing
        for (var i=0; i < platforms.length; i++) {
        	if(platforms[i].exist){
                if(platforms[i].isDestructible){
                    context.fillStyle = DESTRUCTIBLE_PLATFORM_COLOR;
                } else {
                    context.fillStyle = PLATFORM_COLOR ;
                }

                context.fillRect(platforms[i].position.x, platforms[i].position.y, platforms[i].width, platforms [i].height);
            }
        }

        // ladders drawing
        context.fillStyle= LADDER_COLOR ;
        for (var i=0; i < ladders.length; i++) {
        	context.fillRect(ladders[i].position.x, ladders[i].position.y, ladders[i].width, ladders[i].height);
        }

        // balloons displaying
        for(var i=0 ; i<balloons.length ;i++){
            if(balloons[i].radius>0){
                fillCircle(balloons[i]);
            }
        }

        // weapons drawing
        for(var i=0 ; i < weapons.length ; i++){
            var weaponWidth = 0, weaponColor;
            switch(weapons[i].type){
                case GRAPPLE_HOOK_NUMBER :
                    weaponColor = GRAPPLE_HOOK_COLOR;
                    weaponWidth = WEAPON_WIDTH;
                break;

                case TRIDENT_NUMBER :
                    weaponColor = TRIDENT_COLOR ;
                    weaponWidth = WEAPON_WIDTH;
                break;
            }
            context.fillStyle = weaponColor;
            context.fillRect(weapons[i].position.x,weapons[i].position.y,weaponWidth,-weapons[i].length);
        }

        // Drawing of the player
        context.fillStyle = player.color;
        context.fillRect(player.position.x, player.position.y, player.width, player.height);

        // Victory screen
        if(victory){
            context.fillStyle = "green";
            context.fillRect(cvs.width/5,cvs.height/5,cvs.width/5*3,cvs.height/5*3);
            context.fillStyle = "black";
            context.font = '48px serif';
            context.textAlign = "center";
            context.fillText("Et c'est gagné !", cvs.width/2, cvs.height/2);
        }
    }

    /**
    *  Key down event
    */
    captureKeyboardPress = function(event) {
        switch (event.keyCode) {
            // Player1 left or right
            case 39:
            case 37:
                playerMove(event.keyCode);
                break;

            // Player1 up or down
            case 38:
            case 40:
                playerMoveLadder(event.keyCode);
                break;

            // 'P' means pause or unpause
            case 80:
                pause = !pause;
                break;

            // Space for fire the weapon
            case 32:
                shootWeapon(player);
            break;

            // Shortcut to victory                                                                       // BETA FUNCTION
            case 71:
              victory = true;
            break;

            //Activate the default weapon : the grapple hook                                            // BETA FUNCTION
            case 82:
                player.powerOn = GRAPPLE_HOOK_NUMBER ;
                console.log("Grappin activé");
            break;

            //Activate the powerOn Trident                                                              // BETA FUNCTION
            case 84:
                player.powerOn = TRIDENT_NUMBER ;
                console.log("Trident activé");
            break;
        }
    }

    /**
    *  Key up event
    */
    captureKeyboardReleased = function(event) {
        switch (event.keyCode) {
            //Player1 left or right
            case 39:
            case 37:
                playerStopMove(event.keyCode);
                break;
            case 38:
            case 40:
                playerStopMoveLadder();
        }
    }

    </script>
</head>
<body onload="init()">

    <!-- Canvas -->
    <canvas id="cvs" width="800" height="600" style="margin: 10px auto; border: solid 1px #000;"></canvas>

    <!-- About -->
    <p> Commandes :
        <ul>
            <li>R : Arme par défaut</li>
            <li>T : Trident </li>
            <li>G : victoire immédiate</li>
            <li>P : pause</li>
        </ul>
    </p>

    <!-- Pictures -->
    <div style="display: none">
        <img src="bg_paris.jpg" alt="bg_paris" id="bg_paris">
    </div>
</body>
</html>
